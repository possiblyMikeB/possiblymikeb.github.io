{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome &amp; First Steps","text":"<p>For full documentation visit rc.davidson.edu.</p>"},{"location":"#commands","title":"Commands","text":"<p>Note</p> <p>This should look different</p> <p>Question</p> <p>Would it be better to love, live or laugh?</p> <p>Info Can Have Titles</p> <p>blahs blah; is this real or just fantasy?</p> <ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre> <p>Tip</p> <p>Keep an eye on your quota usage.</p>"},{"location":"docs/basics/galaxy/","title":"Galaxy","text":""},{"location":"docs/basics/intro/","title":"First Steps","text":""},{"location":"docs/basics/jupyter/","title":"Jupyter","text":""},{"location":"docs/basics/policy/","title":"Usage Policy","text":""},{"location":"docs/basics/slurm/","title":"SLURM","text":""},{"location":"docs/basics/storage/","title":"Storage","text":""},{"location":"tutorials/ResourceLimits/","title":"CPU Limits &amp; Usage","text":"In\u00a0[\u00a0]: Copied! <pre>ii=0\nwhile ii &lt;= 2*10**8:\n    ii=ii+1\n</pre>  ii=0 while ii &lt;= 2*10**8:     ii=ii+1      <p>Because you have been alloted 2 CPU cores, you should have seen the graph only go up to approximately 50%.  Moreover, because of the constraints placed on this running instance, you will never be able to use more than the alloted 2 CPU cores.</p> In\u00a0[\u00a0]: Copied! <pre># this consumes an exponentially increasing amount of memory.\nbig='small'\nwhile True:\n    big=big+big\n</pre>  # this consumes an exponentially increasing amount of memory. big='small' while True:     big=big+big      <p>You should have seen the Memory usage indicator become red and approach almost 100% before the kernel for this notebook was selected for death by the system's \"Out of Memory Killer.\"</p>"},{"location":"tutorials/ResourceLimits/#cpu-limits-usage","title":"CPU Limits &amp; Usage\u00b6","text":"<p>The default JupyterLab interface provides a CPU &amp; Memory usage indicator in the upper right-hand corner of the application. To see the CPU indicator in action, run the follow cell.</p>"},{"location":"tutorials/ResourceLimits/#memory-limits-usage","title":"Memory Limits &amp; Usage\u00b6","text":"<p>Unlike CPU cycles, memory cannot be oversubscribed (e.g. two people cannot share 1 byte without pre-conditions.) Because of this, memory limits are enforced as hard limits; that is, the system will select and kill one of your processes to keep you from violating the limit.</p> <p>For an example of what that looks like, run the following cell.</p>"},{"location":"tutorials/slurm/advanced-batch-scripting/","title":"Advanced Batch Scripting","text":"<p>SLURM is a powerful tool and, in addition to having a cool name, is used by 70%+ of the systems found on the TOP500 list of most powerful supercomputers.</p> In\u00a0[\u00a0]: Copied! <pre># IDEA:\n#.  start with a batch-script example attempting to access \n#. a restricted partition; have the student modify the \n#. script so that it requests resources somewhere else, then run.\n# \n#. NOTE: should request access to a GPU.\n#.\n</pre> # IDEA: #.  start with a batch-script example attempting to access  #. a restricted partition; have the student modify the  #. script so that it requests resources somewhere else, then run. #  #. NOTE: should request access to a GPU. #.  In\u00a0[\u00a0]: Copied! <pre># IDEA:\n#.  A 1 ntask batch-script which uses `srun` to \n#. launch job-steps, passing different `--output` and\n#. `--job-name` values with each call.\n#.\n</pre> # IDEA: #.  A 1 ntask batch-script which uses `srun` to  #. launch job-steps, passing different `--output` and #. `--job-name` values with each call. #.  In\u00a0[\u00a0]: Copied! <pre># IDEA:\n#.   batch-script that requests one-node, 3 tasks, and 1 cpu per task.\n#. moreover, it should launch more than one job-step and which \n#. passed different values of `-n` &amp;`--job-name` \n#. \n#. NOTE: might use PushShift API  https://pushshift.io/api-parameters/ t\n#.    or their archive of reddit comments https://files.pushshift.io/reddit/comments/\n#.    to search for, or download different things\n#.\n</pre> # IDEA: #.   batch-script that requests one-node, 3 tasks, and 1 cpu per task. #. moreover, it should launch more than one job-step and which  #. passed different values of `-n` &amp;`--job-name`  #.  #. NOTE: might use PushShift API  https://pushshift.io/api-parameters/ t #.    or their archive of reddit comments https://files.pushshift.io/reddit/comments/ #.    to search for, or download different things #.  In\u00a0[\u00a0]: Copied! <pre># IDEA:\n#.    batch-script requests 2 nodes, 1 task-per-node, with \n#.  2 cpus-per-task. akes one call to `srun`. Calls \n#.  a multi-threaded python script (which will be provided).\n#\n</pre> # IDEA: #.    batch-script requests 2 nodes, 1 task-per-node, with  #.  2 cpus-per-task. akes one call to `srun`. Calls  #.  a multi-threaded python script (which will be provided). # In\u00a0[\u00a0]: Copied! <pre># VAUGE THOUGHT: Something using Julia.\n</pre> # VAUGE THOUGHT: Something using Julia. In\u00a0[\u00a0]: Copied! <pre>%%file \"example-four-stage1.sh\"\n#!/bin/bash\n### Job Parameters:\n#SBATCH --job-name \"Stage 1\"             # job name\n#SBATCH --output   \"logs/stage1.%j.log\"  # output file pattern\n\n### Script To Execute:\n# create virtual environment\npython3 -m venv \"env\"\n\n# activate environment\nsource \"env/bin/activate\"\n\n# install packages into environment\npython3 -m pip install numpy\n\n# With python environment setup,\n#    ...  we request \"stage 2\" be scheduled\nsbatch \"example-four-stage2.sh\"\n</pre> %%file \"example-four-stage1.sh\" #!/bin/bash ### Job Parameters: #SBATCH --job-name \"Stage 1\"             # job name #SBATCH --output   \"logs/stage1.%j.log\"  # output file pattern  ### Script To Execute: # create virtual environment python3 -m venv \"env\"  # activate environment source \"env/bin/activate\"  # install packages into environment python3 -m pip install numpy  # With python environment setup, #    ...  we request \"stage 2\" be scheduled sbatch \"example-four-stage2.sh\" In\u00a0[\u00a0]: Copied! <pre>%%file \"example-four-stage2.sh\"\n#!/bin/bash\n### Job Parameters:\n# Request Job-Array\n#SBATCH --array 1-20%10 # the array has 100 sub-jobs (labeled 1 to 100) \n                        # .. with at most 10 sub-jobs running at \n                        # .. any given point.\n# Generic Info for \"sub-job\"\n#SBATCH --job-name \"Stage 2\"               # sub-job name\n#SBATCH --output   \"logs/stage2.%A.%a.log\" # output file pattern\n                                           # .. %A -&gt; array-job-id\n                                           # .. %a -&gt; array-task-id \n# Resources To Request For Each \"sub-job\"\n#SBATCH --ntasks 1\n#SBATCH --cpus-per-task 1\n#SBATCH --mem-per-cpu 500\n#SBATCH --time 00:45:00  \n\n### Script To Execute:\nsource \"env/bin/activate\"         # activate environment from \"stage 1\"\npython3 \"scripts/example-four.py\" # execute python script\n</pre> %%file \"example-four-stage2.sh\" #!/bin/bash ### Job Parameters: # Request Job-Array #SBATCH --array 1-20%10 # the array has 100 sub-jobs (labeled 1 to 100)                          # .. with at most 10 sub-jobs running at                          # .. any given point. # Generic Info for \"sub-job\" #SBATCH --job-name \"Stage 2\"               # sub-job name #SBATCH --output   \"logs/stage2.%A.%a.log\" # output file pattern                                            # .. %A -&gt; array-job-id                                            # .. %a -&gt; array-task-id  # Resources To Request For Each \"sub-job\" #SBATCH --ntasks 1 #SBATCH --cpus-per-task 1 #SBATCH --mem-per-cpu 500 #SBATCH --time 00:45:00    ### Script To Execute: source \"env/bin/activate\"         # activate environment from \"stage 1\" python3 \"scripts/example-four.py\" # execute python script In\u00a0[\u00a0]: Copied! <pre>%%file \"example-four.py\"\n\"\"\"\n File: `example-four.py`\n Synopsis:\n    estimate condition number and print results for \n  a single random perturbation of the nxn identity matrix \n  (where n is fixed).\n\"\"\"\nfrom numpy import eye\nfrom numpy.random import uniform\nfrom numpy.linalg import cond\n\nn = 1000\neps = 0.01\n\nI = eye(n) # nxn identity matix\nX = uniform(size=[n,n])\n\n# generate perturbation `Z`\nZ = I + eps*uniform()*X \n\n# estimate condition number of `Z`\nc = cond(Z)\n\n# print results\nprint(f'{c}', flush=True)\n</pre> %%file \"example-four.py\" \"\"\"  File: `example-four.py`  Synopsis:     estimate condition number and print results for    a single random perturbation of the nxn identity matrix    (where n is fixed). \"\"\" from numpy import eye from numpy.random import uniform from numpy.linalg import cond  n = 1000 eps = 0.01  I = eye(n) # nxn identity matix X = uniform(size=[n,n])  # generate perturbation `Z` Z = I + eps*uniform()*X   # estimate condition number of `Z` c = cond(Z)  # print results print(f'{c}', flush=True) <p>To see what's happening we'll need to switch to a terminal and use the following script.</p> In\u00a0[\u00a0]: Copied! <pre>%%file \"watch-queue.sh\"\n#!/bin/bash\n\n# submit seed job (stage1)\nsbatch \"example-four-stage1.sh\"\n\n# watch queue\nii=0 \nwhile [ $ii -lt 1000 ]; do\n    squeue --user $USER --name \"Stage 1: Example 4\",\"Stage 2: Example 4\"\n    sleep 0.7 &amp;&amp; clear\n    ii=$((ii+1))\ndone\n</pre> %%file \"watch-queue.sh\" #!/bin/bash  # submit seed job (stage1) sbatch \"example-four-stage1.sh\"  # watch queue ii=0  while [ $ii -lt 1000 ]; do     squeue --user $USER --name \"Stage 1: Example 4\",\"Stage 2: Example 4\"     sleep 0.7 &amp;&amp; clear     ii=$((ii+1)) done In\u00a0[\u00a0]: Copied! <pre># IDEA:\n#.  request a two-part job, one portion is the server\n#. the other portion is a client. Start both of them\n#. using one `srun` call. \n#.    SEE EXAMPLES HERE: https://slurm.schedmd.com/heterogeneous_jobs.html \n#.\n</pre> # IDEA: #.  request a two-part job, one portion is the server #. the other portion is a client. Start both of them #. using one `srun` call.  #.    SEE EXAMPLES HERE: https://slurm.schedmd.com/heterogeneous_jobs.html  #."},{"location":"tutorials/slurm/advanced-batch-scripting/#advanced-batch-scripting","title":"Advanced Batch Scripting\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-accounts-partitions-and-qos","title":"Example: Accounts, Partitions, and QOS.\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-job-steps","title":"Example: Job Steps\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-parallel-tasks-serial","title":"Example: Parallel Tasks (Serial)\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-parallel-tasks-threaded","title":"Example: Parallel Tasks (Threaded)\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-job-arrays","title":"Example: Job Arrays\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-multiple-stages","title":"Example: Multiple Stages\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#stage-1-example-four-stage-1sh","title":"Stage 1:  <code>example-four-stage-1.sh</code>\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#stage-2-example-four-stage-2sh","title":"Stage 2: <code>example-four-stage-2.sh</code>\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#python-script-example-fourpy","title":"Python Script: <code>example-four.py</code>\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#submiting-results","title":"Submiting &amp; Results\u00b6","text":""},{"location":"tutorials/slurm/advanced-batch-scripting/#example-5-heterogenous-job","title":"Example 5: Heterogenous Job\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/","title":"Jobs &amp; Batch Scripts","text":"<p>Fundamentally, a job, consists of two things: an allotment of resources &amp; snippets of code to execute using that allotment.\u00a0</p> <p>This means that when we request that SLURM perform some task (say, executing a snippet of code) we are also requesting a resource allotment which will be reserved for the execution of that task.</p> <p>There are a couple of ways we can request a resource allotment and perform tasks.\u00a0</p> <p>We might use the command <code>salloc</code> to request an allotment (by providing arguments on the command-line) and then interactively run code using the the resources once they become available.\u00a0Alternatively, if we want for the task to be performed without needing to interact with it, we can use the command <code>sbatch</code>.</p> <p>Learning the basics of the <code>sbatch</code> command is the purpose of this notebook.</p> <p>When provided the path of a shell-script, the <code>sbatch</code> command searches the script for lines beginning with <code>#SBATCH</code>.  Any line starting with <code>#SBATCH</code> occuring during the preamble (before any commands) is treated as meta-data specifying some parameters for a job we're requesting be created.</p> <p>If these parameters describe a feasible job, that job is created and queued until an appropriate resource allotment (matching the provided parameters) can be made.  Once an appropriate allotment becomes available, the provided shell-script is executed using the alloted resources.</p> <p>Any shell-script containing meta-data that <code>sbatch</code> can understand (say, describing a resource request or providing other ambient details) is called a batch-script (or job-script).</p> <p>Select the cell below and use <code>SHIFT</code>+<code>ENTER</code> to create the batch-script <code>example-one.sh</code>,</p> In\u00a0[\u00a0]: Copied! <pre>%%file example-one.sh\n#!/bin/bash\n### Job Parameters:  \n#SBATCH --job-name \"My Letter\"     # job's name\n#SBATCH --output   \"letter.%j.log\" # output log (%j gets replaced with job's id)\n#SBATCH --comment  \"A humble job.\" # comment about job\n\n### Script To Execute:\namount=$((30 + RANDOM % 60)) # number between 30 and 90\nmemory=$((SLURM_MEM_PER_CPU * SLURM_CPUS_PER_TASK * 1024 * 1024))\ndraft=(\" Dear ${USER},\\n\\n\"\n       \"  I hope this letter finds you well; it is a glorious $(date +%A)\\n\"\n       \"in $(date +%B) and I find myself executing on \"$(hostname -s)\" with\\n\"\n       \"access to ${memory} bytes of memory and $(nproc) cpu(s). Knowing that\\n\"\n       \"these resources are shared, I have chosen to surrender ${amount}\\n\"\n       \"seconds of my alloted time to processes less fortunate than I.\\n\\n\"\n       \"Cheers,\\n\" \"  Job ${SLURM_JOB_ID}\\n\")\n\n# send letter &amp; take a nap.\necho -e \"${draft[@]}\" &amp;&amp; sleep ${amount}\n</pre> %%file example-one.sh #!/bin/bash ### Job Parameters:   #SBATCH --job-name \"My Letter\"     # job's name #SBATCH --output   \"letter.%j.log\" # output log (%j gets replaced with job's id) #SBATCH --comment  \"A humble job.\" # comment about job  ### Script To Execute: amount=$((30 + RANDOM % 60)) # number between 30 and 90 memory=$((SLURM_MEM_PER_CPU * SLURM_CPUS_PER_TASK * 1024 * 1024)) draft=(\" Dear ${USER},\\n\\n\"        \"  I hope this letter finds you well; it is a glorious $(date +%A)\\n\"        \"in $(date +%B) and I find myself executing on \"$(hostname -s)\" with\\n\"        \"access to ${memory} bytes of memory and $(nproc) cpu(s). Knowing that\\n\"        \"these resources are shared, I have chosen to surrender ${amount}\\n\"        \"seconds of my alloted time to processes less fortunate than I.\\n\\n\"        \"Cheers,\\n\" \"  Job ${SLURM_JOB_ID}\\n\")  # send letter &amp; take a nap. echo -e \"${draft[@]}\" &amp;&amp; sleep ${amount}      <p>To submit the batch-script to SLURM, we use the <code>sbatch</code> command. If <code>sbatch</code> successfully creates the job associated with the provided script, it will output the job's id.</p> <p>Select the following cell and use <code>SHIFT</code>+<code>ENTER</code> to evaluate it and submit the example batch-script we created,</p> In\u00a0[\u00a0]: Copied! <pre>sbatch example-one.sh\n</pre> sbatch example-one.sh  <p>Once a job has been successfully submitted, it will appear in the SLURM scheduling queue until it completes. To view jobs currently in the queue, use the command <code>squeue</code>.</p> <p>To view the queue, execute the following cell using <code>SHIFT</code>+<code>ENTER</code> (see if you can locate your job using the JOBID column)</p> In\u00a0[\u00a0]: Copied! <pre>squeue\n</pre> squeue <p>As fun as submitting a job and viewing the queue might be, what happenes once the job executes is fundamentally more important. Complete the task described in the following cell to view the output of your batch-script,</p> In\u00a0[\u00a0]: Copied! <pre># TASK: Identify the line containing `--output` in the batch-script\n#    and use the information provided there to determine the full filename\n#    of the file containing the output from your job.\n#      Place this filename in the quotes below and execute the\n#    cell using SHIFT+ENTER.\n\ncat \"\"\n</pre> # TASK: Identify the line containing `--output` in the batch-script #    and use the information provided there to determine the full filename #    of the file containing the output from your job. #      Place this filename in the quotes below and execute the #    cell using SHIFT+ENTER.  cat \"\" <p>Use <code>SHIFT</code>+<code>ENTER</code> to create the file <code>example-two.sh</code> containing the code from the next cell,</p> In\u00a0[\u00a0]: Copied! <pre>%%file \"example-two.sh\"\n#!/bin/bash\n### Job Parameters:\n#SBATCH --job-name  \"Arguments\" # display name\n#SBATCH --output    \"out.log\"   # where to log terminal output \n#SBATCH --error     \"err.log\"   #  .. and error messages\n#SBATCH --open-mode truncate    # always overwrite log files \n\n# Resources required\n#SBATCH --ntasks 1          # number of tasks we'll perform\n#SBATCH --cpus-per-task 1   # num. cpus each task will require\n#SBATCH --mem-per-cpu 128   # memory required per cpu (in megabytes)\n\n### Script To Execute:\nfor item in \"$@\"; do # loop provided arguments.\n    # print the length of the argument (as a string)\n    echo -n \"The argument '${item}' is ${#item} characters long. \"\n    # and then do something random...\n    amount=$((RANDOM % 6))   # choose `amount` to sleep\n    sleep 0.${amount}        # sleep for `amount/10` seconds\n    echo \"Slept for 0.${amount} seconds.\"\ndone\n</pre> %%file \"example-two.sh\" #!/bin/bash ### Job Parameters: #SBATCH --job-name  \"Arguments\" # display name #SBATCH --output    \"out.log\"   # where to log terminal output  #SBATCH --error     \"err.log\"   #  .. and error messages #SBATCH --open-mode truncate    # always overwrite log files   # Resources required #SBATCH --ntasks 1          # number of tasks we'll perform #SBATCH --cpus-per-task 1   # num. cpus each task will require #SBATCH --mem-per-cpu 128   # memory required per cpu (in megabytes)  ### Script To Execute: for item in \"$@\"; do # loop provided arguments.     # print the length of the argument (as a string)     echo -n \"The argument '${item}' is ${#item} characters long. \"     # and then do something random...     amount=$((RANDOM % 6))   # choose `amount` to sleep     sleep 0.${amount}        # sleep for `amount/10` seconds     echo \"Slept for 0.${amount} seconds.\" done <p>The awesome thing about batch-scripts is they are also shell-scripts. This means we can execute them without needing to go through SLURM, and that the normal testing &amp; development workflow is available.</p> <p>Use <code>SHIFT</code>+<code>ENTER</code> to evaluate the following cell and verify the batch-script works properly,</p> In\u00a0[\u00a0]: Copied! <pre>bash example-two.sh \"first\" second{0..2}\n</pre> bash example-two.sh \"first\" second{0..2}  <p>Optional: In the cell with batch-script's code, locate the line containing --cpus-per-task and change the number of requested CPUs to 2. Save these changes to <code>example-two.sh</code> by evaluating that cell, then verify the script still works appropriately.</p> <p>When you submit a batch-script to SLURM, it's possible to provide a sequence of arguments which will be passed to the script when it executes.</p> <p>Use <code>SHIFT</code>+<code>ENTER</code> to evaluate the following cell and submit the batch-script along with arguments to be used when it executes.</p> In\u00a0[\u00a0]: Copied! <pre>sbatch example-two.sh \"lion\" \"tigers\" argument{1..500}  \"bear\"\n</pre> sbatch example-two.sh \"lion\" \"tigers\" argument{1..500}  \"bear\"  <p>To verify the  submitted job is running, we'll use <code>squeue</code> again.  However, this time, instead of seeing all jobs in the queue, we'll restrict to only jobs associated with our user. To do this we need to use the <code>--user</code> argument for <code>squeue</code>.</p> In\u00a0[\u00a0]: Copied! <pre># excute this cell using SHIFT+ENTER\nsqueue --user $USER\n</pre> # excute this cell using SHIFT+ENTER squeue --user $USER <p>How did we know about the <code>--user</code> argument?</p> <p>We used <code>man</code>. The system command <code>man</code> is an important resource when using UNIX/Linux based systems.  The command provides detailed documentation (or manuals) for various topics, among those topics you'll find \"usage and runtime behavior\" information for a most commands available at a terminal.</p> <p>In the case of <code>squeue</code>, we can learn a lot about what sort of arguments it accepts by skimming the documentation presented by running <code>man squeue</code>. For example, a passage detailing how to use the argument <code>--user</code> is contained within.</p> <p>Use <code>SHIFT</code>+<code>ENTER</code> to evaluate the following cell and display the manual for the <code>squeue</code> command. Then, either by, going to the <code>Edit</code> menu and selecting <code>Find</code>, or using scroll-bar to the right, locate the documentation for the --user option,</p> In\u00a0[\u00a0]: Copied! <pre>man squeue\n</pre> man squeue <p>To finish this example, determine the name of the file containing the job's standard output, then use the <code>cat</code> command to display it's contents.</p> In\u00a0[\u00a0]: Copied! <pre># TASK: display output\n</pre> # TASK: display output <p>Use <code>SHIFT</code>+<code>ENTER</code> to create the file <code>example-three.sh</code> containing the code from the next cell,</p> In\u00a0[\u00a0]: Copied! <pre>%%file \"example-three.sh\"\n#!/bin/bash\n### Job Parameters:\n#SBATCH --job-name \"Recursive\"     # job name\n#SBATCH --output   \"recursive.log\" # place to log output\n#SBATCH --open-mode append         # always append to logs\n#SBATCH --begin     now+10         # specify when the job should start\n                                   # .. (waits 10 seconds after submission)\n### Script To Execute:\n# print job detials\necho \"Running job $SLURM_JOB_ID\"\necho \"Batch script file: $0\"\n\n# submit new job using *this* script (recursion)\nsbatch \"$0\"\n</pre> %%file \"example-three.sh\" #!/bin/bash ### Job Parameters: #SBATCH --job-name \"Recursive\"     # job name #SBATCH --output   \"recursive.log\" # place to log output #SBATCH --open-mode append         # always append to logs #SBATCH --begin     now+10         # specify when the job should start                                    # .. (waits 10 seconds after submission) ### Script To Execute: # print job detials echo \"Running job $SLURM_JOB_ID\" echo \"Batch script file: $0\"  # submit new job using *this* script (recursion) sbatch \"$0\" <p>We'll submit the job to SLURM as normal, however this time we will request that it be considered for execution immediately.</p> In\u00a0[\u00a0]: Copied! <pre># execute this cell using SHIFT+ENTER\nsbatch --begin now example-three.sh\n</pre> # execute this cell using SHIFT+ENTER sbatch --begin now example-three.sh <p>As it turns out, any piece of information which can be provided by an <code>#SBATCH</code> line in a batch-script, can be directly passed to <code>sbatch</code> as a command-line argument (and vice versa).</p> <p>As an example, let's submit a job using the same script, but have the initial job request 1G of memory per cpu, and not start running until after tomorrow at mid-night.</p> In\u00a0[\u00a0]: Copied! <pre># execute this cell using SHIFT+ENTER\nsbatch --mem-per-cpu 1024 --begin tomorrow example-three.sh\n</pre> # execute this cell using SHIFT+ENTER sbatch --mem-per-cpu 1024 --begin tomorrow example-three.sh  <p>Let's check the status of the jobs we've submitted. This time, we'll only request information about jobs with the name \"Recursive\" associated with our user.</p> In\u00a0[\u00a0]: Copied! <pre># execute this cell using SHIFT+ENTER\nsqueue --user $USER --name \"Recursive\"\n</pre> # execute this cell using SHIFT+ENTER squeue --user $USER --name \"Recursive\"  <p>Since these jobs are recursive, they will keep resubmitting themselves forever.</p> <p>As a result, it's important for us to stop (or cancel) any instances which appear in the queue.  To accomplish this, we'll use the command <code>scancel</code>.</p> <p>This command can handle some of the same arguments as <code>squeue</code>. In particular, to cancel all jobs with the name \"Recursive\" associated with our user, we just run,</p> In\u00a0[\u00a0]: Copied! <pre># execute this cell using SHIFT+ENTER\nscancel --user $USER --name \"Recursive\"\n</pre> # execute this cell using SHIFT+ENTER scancel --user $USER --name \"Recursive\" <p>Finally, if you want historical information about the jobs you've submitted, you use the <code>sacct</code> command. Moreover, it has argments which are similar to those of <code>squeue</code>.</p> <p>For example, to see a list of jobs (past and present) associated with your user, we can use the following,</p> In\u00a0[\u00a0]: Copied! <pre># execute this cell using SHIFT+ENTER\nsacct --user $USER\n</pre> # execute this cell using SHIFT+ENTER sacct --user $USER"},{"location":"tutorials/slurm/basic-usage/#jobs-batch-scripts","title":"Jobs &amp; Batch Scripts\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#what-is-a-job","title":"What Is A Job?\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#how-do-we-request-resources-perform-tasks","title":"How Do We Request Resources &amp; Perform Tasks?\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#the-command-sbatch","title":"The command <code>sbatch</code>\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#example-1","title":"Example 1\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#submiting-the-script-getting-results","title":"Submiting The Script &amp; Getting Results\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#example-2","title":"Example 2\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#submiting-the-script-getting-results","title":"Submiting The Script &amp; Getting Results\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#example-3","title":"Example 3\u00b6","text":""},{"location":"tutorials/slurm/basic-usage/#submiting-the-script-getting-results","title":"Submiting The Script &amp; Getting Results\u00b6","text":""},{"location":"tutorials/slurm/containers/","title":"Using Containers","text":"<p><code>TODO: Outline document</code></p> <p>Some interesting links until then:</p> <ol> <li>https://singularity-hub.org/</li> <li>https://github.com/singularityhub/</li> <li>https://github.com/singularityhub/singularity-compose-examples</li> </ol>"},{"location":"tutorials/slurm/containers/#using-containers","title":"Using Containers\u00b6","text":""},{"location":"tutorials/slurm/job-arrays/job-arrays/","title":"Job Arrays","text":"In\u00a0[2]: Copied! <pre>%matplotlib widget\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# pull in ODE def &amp; solver\nfrom three_body import three_body_ode, solve\n</pre> %matplotlib widget import matplotlib.pyplot as plt import numpy as np  # pull in ODE def &amp; solver from three_body import three_body_ode, solve In\u00a0[3]: Copied! <pre>R0 = np.array([\n    [-1.2, -0.80],\n    [ 1.0, -0.83],\n    [ 1.1,  0.80]\n])\n\nsol = solve(R0)\nsol\n</pre>  R0 = np.array([     [-1.2, -0.80],     [ 1.0, -0.83],     [ 1.1,  0.80] ])  sol = solve(R0) sol  Out[3]: <pre>array([[[-1.2       , -0.8       ],\n        [ 1.        , -0.83      ],\n        [ 1.1       ,  0.8       ]],\n\n       [[-1.19999979, -0.79999996],\n        [ 0.99999994, -0.82999983],\n        [ 1.09999995,  0.79999977]],\n\n       [[-1.19999917, -0.79999983],\n        [ 0.99999974, -0.82999932],\n        [ 1.09999978,  0.79999906]],\n\n       ...,\n\n       [[ 0.01779596, -3.96171236],\n        [ 0.01973524, -3.96095831],\n        [ 1.50673095,  6.61195546]],\n\n       [[ 0.01804623, -3.96136095],\n        [ 0.01956476, -3.9614291 ],\n        [ 1.50677705,  6.61230022]],\n\n       [[ 0.01848101, -3.96153585],\n        [ 0.01929669, -3.9616215 ],\n        [ 1.50682315,  6.61264496]]])</pre> <p>We'll now plot the computed trajectories, indicating the initial positions of each body with a red cross symbol.</p> In\u00a0[4]: Copied! <pre>plt.title(f'$R_0 = [{\" ,\".join(map(str,R0.flatten()))}]$')\nfor ii in range(3):\n    plt.plot(sol[:,ii,0],sol[:,ii,1])\n    \nplt.scatter(\n    sol[0,:,0], sol[0,:,1],\n    c='r', marker='+', s=30\n)\n</pre>  plt.title(f'$R_0 = [{\" ,\".join(map(str,R0.flatten()))}]$') for ii in range(3):     plt.plot(sol[:,ii,0],sol[:,ii,1])      plt.scatter(     sol[0,:,0], sol[0,:,1],     c='r', marker='+', s=30 )  Out[4]: <pre>&lt;matplotlib.collections.PathCollection at 0x15211ab18af0&gt;</pre> <p>Translating this to something tangible, it can be understood as requiring that we only compute solutions with initial values chosen randomly using a function like:</p> In\u00a0[5]: Copied! <pre>random_position = lambda : np.array([\n      [np.random.normal(-1, 0.25), np.random.normal(-1, 0.25)],\n      [np.random.normal( 1, 0.25), np.random.normal(-1, 0.25)],\n      [np.random.normal( 1, 0.25), np.random.normal( 1, 0.25)]\n  ])\n</pre>  random_position = lambda : np.array([       [np.random.normal(-1, 0.25), np.random.normal(-1, 0.25)],       [np.random.normal( 1, 0.25), np.random.normal(-1, 0.25)],       [np.random.normal( 1, 0.25), np.random.normal( 1, 0.25)]   ])  <p>However, because of the way pseudo-random numbers are generated by <code>numpy</code>; we can't simply put the code from the above cell in <code>three_body.py</code> then run it a bunch of times, since this would result in extremely poor sampling/parameter-selection</p> In\u00a0[6]: Copied! <pre># sample-size/number of parameters\nN = 5000\n\n# generating and sorting the sample/parameters\nwith open('parameters.txt', 'w') as params_file:\n    for _ in range(N):\n        # observe a random positiion \n        initial_pos = random_position().flatten()\n        # store in `params_file` for use later\n        print(' '.join(['{:0.5f}']*6).format(*initial_pos), file=params_file)\n</pre> # sample-size/number of parameters N = 5000  # generating and sorting the sample/parameters with open('parameters.txt', 'w') as params_file:     for _ in range(N):         # observe a random positiion          initial_pos = random_position().flatten()         # store in `params_file` for use later         print(' '.join(['{:0.5f}']*6).format(*initial_pos), file=params_file)  In\u00a0[1]: Copied! <pre>!sed -n 2134p \"parameters.txt\"\n</pre> !sed -n 2134p \"parameters.txt\" <pre>-0.74574 -1.21814 0.83396 -1.07720 0.81459 0.85784\n</pre> <p>What's important about this is that SLURM Job Arrays provide us a sane mechanism we can use to index a collection of jobs.</p> <p>It does this by making available the <code>SLURM_ARRAY_TASK_ID</code> environment variable inside of each executing job for the array.</p> In\u00a0[\u00a0]: Copied! <pre>#SBATCH --array 1-1000%25\n</pre>  #SBATCH --array 1-1000%25"},{"location":"tutorials/slurm/job-arrays/job-arrays/#job-arrays","title":"Job Arrays\u00b6","text":""},{"location":"tutorials/slurm/job-arrays/job-arrays/#example-three-body-computation","title":"Example Three Body Computation\u00b6","text":"<p>We'll find an approximate the solution using the value of $R_0$ below</p>"},{"location":"tutorials/slurm/job-arrays/job-arrays/#specializing-on-a-familty-of-initial-values","title":"Specializing On A Familty of Initial Values\u00b6","text":"<p>For the purposes of this example, we're interested in collecting information about the behavior of solutions to the three body problem (in 2D) when the initial positions ($r_1$, $r_2$ and $r_3$) are chosen so as to satisfy: $$ \\begin{align}  r_1 &amp; \\sim \\mathcal{N}_2\\left([-1,-1],\\ 0.25\\cdot I_2\\right) \\\\  r_2 &amp; \\sim \\mathcal{N}_2\\left([\\ \\ \\ 1,-1],\\ 0.25 \\cdot I_2\\right) \\\\  r_3 &amp; \\sim \\mathcal{N}_2\\left([\\ \\ \\ 1, \\ \\ \\ 1],\\ 0.25\\cdot I_2\\right) \\\\ \\end{align} $$</p>"},{"location":"tutorials/slurm/job-arrays/job-arrays/#workaround","title":"Workaround\u00b6","text":"<p>We have to be deliberate with how we choose and distribute the initial positions. There are several ways we can accomplish this vague task, however in this example we'll only concern ourselves with one.</p> <p>In this case, what we are going to do is create one very large sample/parameter-list which satisfies the conditions we are looking for, and then use <code>SLURM</code> to schedule the computations.</p>"},{"location":"tutorials/slurm/job-arrays/job-arrays/#where-job-arrays-come-in","title":"Where Job Arrays Come In\u00b6","text":"<p>We can index the <code>parameters.txt</code> using line numbers, and this is fairly standard to do:</p>"},{"location":"tutorials/slurm/job-arrays/three_body/","title":"Three body","text":"In\u00a0[\u00a0]: Copied! <pre>import sys, hashlib, os\nimport numpy as np\nfrom scipy.integrate import solve_ivp\nimport matplotlib.pyplot as plt\n</pre> import sys, hashlib, os import numpy as np from scipy.integrate import solve_ivp import matplotlib.pyplot as plt In\u00a0[\u00a0]: Copied! <pre># initial mass for each of the three bodies\nM0 = np.array([\n    0.8,\n    1.1,\n    1.0\n])\n</pre> # initial mass for each of the three bodies M0 = np.array([     0.8,     1.1,     1.0 ]) In\u00a0[\u00a0]: Copied! <pre># initial momenta ...\nP0 = np.array([\n   [0.0, 0.0],\n   [0.0, 0.0],\n   [0.0, 0.0]\n])\n</pre> # initial momenta ... P0 = np.array([    [0.0, 0.0],    [0.0, 0.0],    [0.0, 0.0] ]) In\u00a0[\u00a0]: Copied! <pre># initial positions ...\nR0 = None\n</pre> # initial positions ... R0 = None In\u00a0[\u00a0]: Copied! <pre># rhs of autonomous ODE system\ndef three_body_ode(t, s):\n    \"\"\"\n    Name: threebody_ode_sys\n    Synop:\n        calculates the instantaneous values of the time-derivative\n      of state variables for a system of three bodies only\n      under the influence of non-rel gravity in 2D.\n    Assumption:\n       s[0:6] code the position of the bodies\n       s[6:12] code the momenta ...\n       s[12:15] code the masses ...\n    \"\"\"\n    r12=np.sqrt((s[0]-s[2])**2 + (s[1]-s[3])**2)**3\n    r13=np.sqrt((s[0]-s[4])**2 + (s[1]-s[5])**2)**3\n    r23=np.sqrt((s[2]-s[4])**2 + (s[3]-s[5])**2)**3\n    return [\n        s[6+0]/s[12+0],\n        s[6+1]/s[12+0],\n        s[6+2]/s[12+1],\n        s[6+3]/s[12+1],\n        s[6+4]/s[12+2],\n        s[6+5]/s[12+2],\n        - s[12+1]*(s[0]-s[2])/r12 - s[12+2]*(s[0]-s[4])/r13,\n        - s[12+1]*(s[1]-s[3])/r12 - s[12+2]*(s[1]-s[5])/r13,\n        - s[12+0]*(s[2]-s[0])/r12 - s[12+2]*(s[2]-s[4])/r23,\n        - s[12+0]*(s[3]-s[1])/r12 - s[12+2]*(s[3]-s[5])/r23,\n        - s[12+0]*(s[4]-s[0])/r13 - s[12+1]*(s[4]-s[2])/r23,\n        - s[12+0]*(s[5]-s[1])/r13 - s[12+1]*(s[5]-s[3])/r23,\n        0.0,\n        0.0,\n        0.0\n    ]\n</pre> # rhs of autonomous ODE system def three_body_ode(t, s):     \"\"\"     Name: threebody_ode_sys     Synop:         calculates the instantaneous values of the time-derivative       of state variables for a system of three bodies only       under the influence of non-rel gravity in 2D.     Assumption:        s[0:6] code the position of the bodies        s[6:12] code the momenta ...        s[12:15] code the masses ...     \"\"\"     r12=np.sqrt((s[0]-s[2])**2 + (s[1]-s[3])**2)**3     r13=np.sqrt((s[0]-s[4])**2 + (s[1]-s[5])**2)**3     r23=np.sqrt((s[2]-s[4])**2 + (s[3]-s[5])**2)**3     return [         s[6+0]/s[12+0],         s[6+1]/s[12+0],         s[6+2]/s[12+1],         s[6+3]/s[12+1],         s[6+4]/s[12+2],         s[6+5]/s[12+2],         - s[12+1]*(s[0]-s[2])/r12 - s[12+2]*(s[0]-s[4])/r13,         - s[12+1]*(s[1]-s[3])/r12 - s[12+2]*(s[1]-s[5])/r13,         - s[12+0]*(s[2]-s[0])/r12 - s[12+2]*(s[2]-s[4])/r23,         - s[12+0]*(s[3]-s[1])/r12 - s[12+2]*(s[3]-s[5])/r23,         - s[12+0]*(s[4]-s[0])/r13 - s[12+1]*(s[4]-s[2])/r23,         - s[12+0]*(s[5]-s[1])/r13 - s[12+1]*(s[5]-s[3])/r23,         0.0,         0.0,         0.0     ] In\u00a0[\u00a0]: Copied! <pre>def solve(r0=R0, p0=P0, m0=M0, t_max=50.0, t_delta=0.001):\n    \"\"\"\n    Name: solve\n    Synop:\n      assemble initial conditions and return approximate\n     solution to ODE system.\n    \"\"\"\n    # holds initial ODE-system state\n    s0 = np.zeros(15)\n\n    # assign initial masses\n    s0[12:15] = m0\n    # initial momenta ...\n    s0[6:12] = p0.flatten()\n    # initial positions ...\n    s0[0:6] = r0.flatten()\n\n    # assemble simple t-mesh\n    t_eval = np.arange(0, t_max+t_delta, t_delta)\n\n    # compute &amp; return apporximate solution to ODE sys on `t`-mesh\n    sol = solve_ivp(\n        three_body_ode, [0, t_max], s0,\n        t_eval=t_eval\n    )\n\n    return np.reshape(\n        sol.y.T[:,:6],\n        (sol.y.shape[-1], 3, 2)\n    )\n</pre> def solve(r0=R0, p0=P0, m0=M0, t_max=50.0, t_delta=0.001):     \"\"\"     Name: solve     Synop:       assemble initial conditions and return approximate      solution to ODE system.     \"\"\"     # holds initial ODE-system state     s0 = np.zeros(15)      # assign initial masses     s0[12:15] = m0     # initial momenta ...     s0[6:12] = p0.flatten()     # initial positions ...     s0[0:6] = r0.flatten()      # assemble simple t-mesh     t_eval = np.arange(0, t_max+t_delta, t_delta)      # compute &amp; return apporximate solution to ODE sys on `t`-mesh     sol = solve_ivp(         three_body_ode, [0, t_max], s0,         t_eval=t_eval     )      return np.reshape(         sol.y.T[:,:6],         (sol.y.shape[-1], 3, 2)     ) In\u00a0[\u00a0]: Copied! <pre>def main():\n    # parse commandline arguments\n    try:\n        R0 = np.array(list(map(float, sys.argv[1:])))\n    except:\n        print(\"ERROR: must provide exactly six floating point values\"\n              \" as commandline arguments\")\n        return 1\n\n    # solve three-body problem for given ICs\n    sol = solve(R0)\n\n    # generate plot showing evoluation of bodies\n    plt.figure(figsize = (12, 8))\n    plt.title(f'$R_0 = [{\", \".join(sys.argv[1:])}]$')\n    # trajectories\n    for ii in range(3):\n        plt.plot(sol[:, ii, 0], sol[:, ii, 1])\n\n    # starting position\n    plt.scatter(\n        sol[0,:,0], sol[0,:,1], c='r', marker='+', s=30)\n\n    plt.xlim([-2.5,2.5])\n    plt.ylim([-2.5,2.5])\n    plt.xlabel('x')\n    plt.ylabel('y')\n\n    # generate unique filename\n    imgfile = hashlib.sha256(\n        ','.join(sys.argv[1:]).encode('utf-8')\n    ).hexdigest() + '.png'\n\n    # save plot\n    plt.savefig(os.path.join('imgs', imgfile))\n    return 0\n</pre> def main():     # parse commandline arguments     try:         R0 = np.array(list(map(float, sys.argv[1:])))     except:         print(\"ERROR: must provide exactly six floating point values\"               \" as commandline arguments\")         return 1      # solve three-body problem for given ICs     sol = solve(R0)      # generate plot showing evoluation of bodies     plt.figure(figsize = (12, 8))     plt.title(f'$R_0 = [{\", \".join(sys.argv[1:])}]$')     # trajectories     for ii in range(3):         plt.plot(sol[:, ii, 0], sol[:, ii, 1])      # starting position     plt.scatter(         sol[0,:,0], sol[0,:,1], c='r', marker='+', s=30)      plt.xlim([-2.5,2.5])     plt.ylim([-2.5,2.5])     plt.xlabel('x')     plt.ylabel('y')      # generate unique filename     imgfile = hashlib.sha256(         ','.join(sys.argv[1:]).encode('utf-8')     ).hexdigest() + '.png'      # save plot     plt.savefig(os.path.join('imgs', imgfile))     return 0 In\u00a0[\u00a0]: Copied! <pre>if __name__ == \"__main__\":\n    sys.exit(main())\n    pass\n</pre> if __name__ == \"__main__\":     sys.exit(main())     pass"}]}